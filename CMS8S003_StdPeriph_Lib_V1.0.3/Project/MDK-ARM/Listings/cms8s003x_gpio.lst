C51 COMPILER V9.56.0.0   CMS8S003X_GPIO                                                    05/29/2018 18:09:10 PAGE 1   


C51 COMPILER V9.56.0.0, COMPILATION OF MODULE CMS8S003X_GPIO
OBJECT MODULE PLACED IN .\Objects\cms8s003x_gpio.obj
COMPILER INVOKED BY: C:\Keil_v5\C51\BIN\C51.EXE ..\..\Libraries\CMS8S003x_StdPeriph_Driver\src\cms8s003x_gpio.c OMF2 OPT
                    -IMIZE(8,SPEED) BROWSE INCDIR(..\..\Libraries\CMS8S003x_StdPeriph_Driver\inc) DEBUG PRINT(.\Listings\cms8s003x_gpio.lst) 
                    -TABS(2) OBJECT(.\Objects\cms8s003x_gpio.obj)

line level    source

   1          /**
   2            ******************************************************************************
   3            * @file    cms8s003x_gpio.c
   4            * @author  LI WEI
   5            * @version V1.0.0
   6            * @date    04/24/2018
   7            * @brief   This file provides all the GPIO firmware functions.
   8            ******************************************************************************
   9            * @copy
  10            *
  11            * THE PRESENT FIRMWARE WHICH IS FOR GUIDANCE ONLY AIMS AT PROVIDING CUSTOMERS
  12            * WITH CODING INFORMATION REGARDING THEIR PRODUCTS IN ORDER FOR THEM TO SAVE
  13            * TIME. AS A RESULT, CMSemicon SHALL NOT BE HELD LIABLE FOR ANY
  14            * DIRECT, INDIRECT OR CONSEQUENTIAL DAMAGES WITH RESPECT TO ANY CLAIMS ARISING
  15            * FROM THE CONTENT OF SUCH FIRMWARE AND/OR THE USE MADE BY CUSTOMERS OF THE
  16            * CODING INFORMATION CONTAINED HEREIN IN CONNECTION WITH THEIR PRODUCTS.
  17            *
  18            * <h2><center>&copy; COPYRIGHT 2018 CMSemicon</center></h2>
  19            */
  20          
  21          /* Includes ------------------------------------------------------------------*/
  22          #include "cms8s003x_gpio.h"
  23          #include <CMS\CMS8S003.H>
  24          #include "cms8s003x_conf.h"
  25          
  26          /** @addtogroup cms8s003x_StdPeriph_Driver
  27            * @{
  28            */
  29          
  30          /* Private typedef -----------------------------------------------------------*/
  31          /* Private define ------------------------------------------------------------*/
  32          /* Private macro -------------------------------------------------------------*/
  33          /* Private variables ---------------------------------------------------------*/
  34          /* Private function prototypes -----------------------------------------------*/
  35          /* Private functions ---------------------------------------------------------*/
  36          
  37          /**
  38            * @addtogroup GPIO_Public_Functions
  39            * @{
  40            */
  41          
  42          /**
  43            * @brief  Deinitializes the GPIOx peripheral registers to their default reset values.
  44            * @param  GPIOx: Select the GPIO peripheral number (x = A to I).
  45            * @retval None
  46            */
  47          void GPIO_DeInit(GPIO_Port_Typedef GPIOx)
  48          {
  49   1      
  50   1      }
*** WARNING C280 IN LINE 47 OF ..\..\Libraries\CMS8S003x_StdPeriph_Driver\src\cms8s003x_gpio.c: 'GPIOx': unreferenced lo
             -cal variable
  51          
C51 COMPILER V9.56.0.0   CMS8S003X_GPIO                                                    05/29/2018 18:09:10 PAGE 2   

  52          /**
  53            * @brief  Initializes the GPIOx according to the specified parameters.
  54            * @param  GPIOx : Select the GPIO peripheral number (x = A to I).
  55            * @param  GPIO_Pin : This parameter contains the pin number, it can be any value
  56            *         of the @ref GPIO_Pin_TypeDef enumeration.
  57            * @param  GPIO_Mode : This parameter can be a value of the
  58            *         @Ref GPIO_Mode_TypeDef enumeration.
  59            * @retval None
  60            */
  61          uint8_t readTest = 0;
  62          void GPIO_Init(GPIO_Port_Typedef GPIOx, GPIO_Init_TypeDef* GPIO_InitParam)
  63          {
  64   1        //assert_param(IS_GPIO_MODE(GPIO_Mode));
  65   1        //assert_param(IS_GPIO_PIN(GPIO_Pin));
  66   1      
  67   1        if(GPIOx == GPIO_PORT_0)
  68   1        {
  69   2            if(GPIO_InitParam->Mode == GPIO_PIN)
  70   2            {
  71   3                *(volatile unsigned char xdata *)(P0CFG +(uint8_t)GPIO_InitParam->Pin) = 0;
  72   3            }
  73   2            if(GPIO_InitParam->Direction == GPIO_INPUT)                 P0TRIS &= ~GPIO_InitParam->Pin;   //ÊäÈëÄ£Ê½
  74   2            if(GPIO_InitParam->Direction == GPIO_OUTPUT)                P0TRIS |= GPIO_InitParam->Pin;    //Êä³öÄ£Ê½
  75   2            if(GPIO_InitParam->Analog == GPIO_Digital_Sel)              P0ANS &= ~GPIO_InitParam->Pin;    //Êý×Ö¶Ë¿Ú   
             - 
  76   2            if(GPIO_InitParam->Analog == GPIO_Analog_Sel)               P0ANS |= GPIO_InitParam->Pin;     //Ä£Äâ¶Ë¿Ú
  77   2            if(GPIO_InitParam->OType == GPIO_Pushpull_Sel)              P0OD &= ~GPIO_InitParam->Pin;     //Õý³£×´Ì¬(ÍÆ
             -Íì)
  78   2            if(GPIO_InitParam->OType == GPIO_Opendrain_Sel)             P0OD |= GPIO_InitParam->Pin;      //¿ªÂ©Ä£Ê½
  79   2            if(GPIO_InitParam->Up == GPIO_Up_Disable)                   P0UP &= ~GPIO_InitParam->Pin;     //¹Ø±ÕÉÏÀ­
  80   2            if(GPIO_InitParam->Up == GPIO_Up_Enable)                    P0UP |= GPIO_InitParam->Pin;      //¿ªÆôÉÏÀ­
  81   2            if(GPIO_InitParam->Down == GPIO_Down_Disable)               P0DOWN &= ~GPIO_InitParam->Pin;     //¹Ø±ÕÏÂÀ­
  82   2            if(GPIO_InitParam->Down == GPIO_Down_Enable)                P0DOWN |= GPIO_InitParam->Pin;      //¿ªÆôÏÂÀ­
  83   2            if(GPIO_InitParam->Driver == GPIO_Driver_Strong)            P0DR &= ~GPIO_InitParam->Pin;     //ÈõµçÁ÷Çý¶
             -¯
  84   2            if(GPIO_InitParam->Driver == GPIO_Driver_Weak)              P0DR |= GPIO_InitParam->Pin;      //Ç¿µçÁ÷Çý¶¯
  85   2            if(GPIO_InitParam->Slope == GPIO_Slope_Fast)                P0SR &= ~GPIO_InitParam->Pin;     //¿ìÐ±ÂÊ
  86   2            if(GPIO_InitParam->Slope == GPIO_Slope_Slow)                P0SR |= GPIO_InitParam->Pin;      //ÂýÐ±ÂÊ
  87   2        }
  88   1        else if(GPIOx == GPIO_PORT_1)
  89   1        {
  90   2            if(GPIO_InitParam->Mode == GPIO_PIN)
  91   2            {
  92   3                *(volatile unsigned char xdata *)(P1CFG +(uint8_t)GPIO_InitParam->Pin) = 0;
  93   3                //readTest = P15CFG;
  94   3            }
  95   2            if(GPIO_InitParam->Direction == GPIO_INPUT)                 P1TRIS &= ~(1 << GPIO_InitParam->Pin);   //ÊäÈëÄ
             -£Ê½
  96   2            if(GPIO_InitParam->Direction == GPIO_OUTPUT)                P1TRIS |= (1 << GPIO_InitParam->Pin);    //Êä³öÄ£
             -Ê½
  97   2            if(GPIO_InitParam->Analog == GPIO_Digital_Sel)              P1ANS &= ~(1 << GPIO_InitParam->Pin);    //Êý×Ö
             -¶Ë¿Ú    
  98   2            if(GPIO_InitParam->Analog == GPIO_Analog_Sel)               P1ANS |= (1 << GPIO_InitParam->Pin);    //Ä£Äâ¶
             -Ë¿Ú
  99   2            if(GPIO_InitParam->OType == GPIO_Pushpull_Sel)              P1OD &= ~(1 << GPIO_InitParam->Pin);     //Õý³£
             -×´Ì¬(ÍÆÍì)
 100   2            if(GPIO_InitParam->OType == GPIO_Opendrain_Sel)             P1OD |= (1 << GPIO_InitParam->Pin);      //¿ªÂ©
             -Ä£Ê½
 101   2            if(GPIO_InitParam->Up == GPIO_Up_Disable)                   P1UP &= ~(1 << GPIO_InitParam->Pin);     //¹Ø±ÕÉÏ
             -À­
 102   2            if(GPIO_InitParam->Up == GPIO_Up_Enable)                    P1UP |= (1 << GPIO_InitParam->Pin);      //¿ªÆôÉÏÀ
             -­
C51 COMPILER V9.56.0.0   CMS8S003X_GPIO                                                    05/29/2018 18:09:10 PAGE 3   

 103   2            if(GPIO_InitParam->Down == GPIO_Down_Disable)               P1DOWN &= ~(1 << GPIO_InitParam->Pin);   //¹Ø±Õ
             -ÏÂÀ­
 104   2            if(GPIO_InitParam->Down == GPIO_Down_Enable)                P1DOWN |= (1 << GPIO_InitParam->Pin);    //¿ªÆôÏ
             -ÂÀ­
 105   2            if(GPIO_InitParam->Driver == GPIO_Driver_Strong)            P1DR &= ~(1 << GPIO_InitParam->Pin);     //Èõ
             -µçÁ÷Çý¶¯
 106   2            if(GPIO_InitParam->Driver == GPIO_Driver_Weak)              P1DR |= (1 << GPIO_InitParam->Pin);      //Ç¿µç
             -Á÷Çý¶¯
 107   2            if(GPIO_InitParam->Slope == GPIO_Slope_Fast)                P1SR &= ~(1 << GPIO_InitParam->Pin);     //¿ìÐ±
             -ÂÊ
 108   2            if(GPIO_InitParam->Slope == GPIO_Slope_Slow)                P1SR |= (1 << GPIO_InitParam->Pin);      //ÂýÐ±Â
             -Ê
 109   2        }
 110   1        else if(GPIOx == GPIO_PORT_2)
 111   1        {
 112   2            if(GPIO_InitParam->Mode == GPIO_PIN)
 113   2            {
 114   3                *(volatile unsigned char xdata *)(P2CFG +(uint8_t)GPIO_InitParam->Pin) = 0;
 115   3                
 116   3            }
 117   2            if(GPIO_InitParam->Direction == GPIO_INPUT)                 P2TRIS &= ~GPIO_InitParam->Pin;   //ÊäÈëÄ£Ê½
 118   2            if(GPIO_InitParam->Direction == GPIO_OUTPUT)                P2TRIS |= GPIO_InitParam->Pin;    //Êä³öÄ£Ê½
 119   2            if(GPIO_InitParam->Analog == GPIO_Digital_Sel)              P2ANS &= ~GPIO_InitParam->Pin;    //Êý×Ö¶Ë¿Ú   
             - 
 120   2            if(GPIO_InitParam->Analog == GPIO_Analog_Sel)               P2ANS |= GPIO_InitParam->Pin;      //Ä£Äâ¶Ë¿Ú
 121   2            if(GPIO_InitParam->OType == GPIO_Pushpull_Sel)              P2OD &= ~GPIO_InitParam->Pin;     //Õý³£×´Ì¬(ÍÆ
             -Íì)
 122   2            if(GPIO_InitParam->OType == GPIO_Opendrain_Sel)             P2OD |= GPIO_InitParam->Pin;      //¿ªÂ©Ä£Ê½
 123   2            if(GPIO_InitParam->Up == GPIO_Up_Disable)                   P2UP &= ~GPIO_InitParam->Pin;     //¹Ø±ÕÉÏÀ­
 124   2            if(GPIO_InitParam->Up == GPIO_Up_Enable)                    P2UP |= GPIO_InitParam->Pin;      //¿ªÆôÉÏÀ­
 125   2            if(GPIO_InitParam->Down == GPIO_Down_Disable)               P2DOWN &= ~GPIO_InitParam->Pin;     //¹Ø±ÕÏÂÀ­
 126   2            if(GPIO_InitParam->Down == GPIO_Down_Enable)                P2DOWN |= GPIO_InitParam->Pin;      //¿ªÆôÏÂÀ­
 127   2            if(GPIO_InitParam->Driver == GPIO_Driver_Strong)            P2DR &= ~GPIO_InitParam->Pin;     //ÈõµçÁ÷Çý¶
             -¯
 128   2            if(GPIO_InitParam->Driver == GPIO_Driver_Weak)              P2DR |= GPIO_InitParam->Pin;      //Ç¿µçÁ÷Çý¶¯
 129   2            if(GPIO_InitParam->Slope == GPIO_Slope_Fast)                P2SR &= ~GPIO_InitParam->Pin;     //¿ìÐ±ÂÊ
 130   2            if(GPIO_InitParam->Slope == GPIO_Slope_Slow)                P2SR |= GPIO_InitParam->Pin;      //ÂýÐ±ÂÊ
 131   2        }
 132   1        else if(GPIOx == GPIO_PORT_3)
 133   1        {
 134   2            if(GPIO_InitParam->Mode == GPIO_PIN)
 135   2            {
 136   3                *(volatile unsigned char xdata *)(P3CFG +(uint8_t)GPIO_InitParam->Pin) = 0;
 137   3            }
 138   2            if(GPIO_InitParam->Direction == GPIO_INPUT)                 P3TRIS &= ~GPIO_InitParam->Pin;   //ÊäÈëÄ£Ê½
 139   2            if(GPIO_InitParam->Direction == GPIO_OUTPUT)                P3TRIS |= GPIO_InitParam->Pin;    //Êä³öÄ£Ê½
 140   2            if(GPIO_InitParam->Analog == GPIO_Digital_Sel)              P3ANS &= ~GPIO_InitParam->Pin;    //Êý×Ö¶Ë¿Ú   
             - 
 141   2            if(GPIO_InitParam->Analog == GPIO_Analog_Sel)               P3ANS |= GPIO_InitParam->Pin;      //Ä£Äâ¶Ë¿Ú
 142   2            if(GPIO_InitParam->OType == GPIO_Pushpull_Sel)              P3OD &= ~GPIO_InitParam->Pin;     //Õý³£×´Ì¬(ÍÆ
             -Íì)
 143   2            if(GPIO_InitParam->OType == GPIO_Opendrain_Sel)             P3OD |= GPIO_InitParam->Pin;      //¿ªÂ©Ä£Ê½
 144   2            if(GPIO_InitParam->Up == GPIO_Up_Disable)                   P3UP &= ~GPIO_InitParam->Pin;     //¹Ø±ÕÉÏÀ­
 145   2            if(GPIO_InitParam->Up == GPIO_Up_Enable)                    P3UP |= GPIO_InitParam->Pin;      //¿ªÆôÉÏÀ­
 146   2            if(GPIO_InitParam->Down == GPIO_Down_Disable)               P3DOWN &= ~GPIO_InitParam->Pin;     //¹Ø±ÕÏÂÀ­
 147   2            if(GPIO_InitParam->Down == GPIO_Down_Enable)                P3DOWN |= GPIO_InitParam->Pin;      //¿ªÆôÏÂÀ­
 148   2            if(GPIO_InitParam->Driver == GPIO_Driver_Strong)            P3DR &= ~GPIO_InitParam->Pin;     //ÈõµçÁ÷Çý¶
             -¯
 149   2            if(GPIO_InitParam->Driver == GPIO_Driver_Weak)              P3DR |= GPIO_InitParam->Pin;      //Ç¿µçÁ÷Çý¶¯
 150   2            if(GPIO_InitParam->Slope == GPIO_Slope_Fast)                P3SR &= ~GPIO_InitParam->Pin;     //¿ìÐ±ÂÊ
 151   2            if(GPIO_InitParam->Slope == GPIO_Slope_Slow)                P3SR |= GPIO_InitParam->Pin;      //ÂýÐ±ÂÊ
 152   2        }
C51 COMPILER V9.56.0.0   CMS8S003X_GPIO                                                    05/29/2018 18:09:10 PAGE 4   

 153   1      }
 154          
 155          #if 1
 156          /**
 157            * @brief  Writes data to the specified GPIO data port.
 158            * @note   The port must be configured in output mode.
 159            * @param  GPIOx : Select the GPIO peripheral number (x = A to I).
 160            * @param  GPIO_PortVal : Specifies the value to be written to the port output
 161            *         data register.
 162            * @retval None
 163            */
 164          void GPIO_Write(GPIO_Port_Typedef GPIOx, uint8_t GPIO_PortVal)
 165          {
 166   1        if(GPIOx == GPIO_PORT_0)
 167   1        {
 168   2          P0 = GPIO_PortVal;
 169   2        }else if(GPIOx == GPIO_PORT_1)
 170   1        {
 171   2          P1 = GPIO_PortVal;
 172   2        }else if(GPIOx == GPIO_PORT_2)
 173   1        {
 174   2          P2 = GPIO_PortVal;
 175   2        }else if(GPIOx == GPIO_PORT_3)
 176   1        {
 177   2          P3 = GPIO_PortVal;
 178   2        }else
 179   1        {
 180   2      
 181   2        }
 182   1      }
 183          
 184          /**
 185            * @brief  Sets or clears the selected data port bit.
 186            * @param  GPIOx : Select the GPIO peripheral number (x = A to I).
 187            * @param  GPIO_Pin: Specifies the port bit to be written.
 188            *         This parameter can be a value of GPIO_Pin_TypeDef enumeration.
 189            * @param  GPIO_BitVal: specifies the desired status to be written.
 190            *         This parameter can be a value of @ref BitAction enumeration.
 191            * @retval None
 192            */
 193          void GPIO_WriteBit(GPIO_Port_Typedef GPIOx, GPIO_Pin_TypeDef GPIO_Pin, BitAction GPIO_BitVal)
 194          {
 195   1        /* Check the parameters */
 196   1        //assert_param(IS_GPIO_PIN(GPIO_Pin));
 197   1        //assert_param(IS_STATE_VALUE(GPIO_BitVal));
 198   1      
 199   1        if(GPIOx == GPIO_PORT_0)
 200   1        {
 201   2         if (GPIO_BitVal != _RESET)
 202   2         {
 203   3            P0  |= (1 << GPIO_Pin);
 204   3         }else
 205   2         {
 206   3            P0  &= (uint8_t)(~(1 << GPIO_Pin));
 207   3         }
 208   2        }else if(GPIOx == GPIO_PORT_1)
 209   1        {
 210   2         if (GPIO_BitVal != _RESET)
 211   2         {
 212   3            P1  |= (1 << GPIO_Pin);
 213   3         }else
 214   2         {
C51 COMPILER V9.56.0.0   CMS8S003X_GPIO                                                    05/29/2018 18:09:10 PAGE 5   

 215   3            P1  &= (uint8_t)(~(1 << GPIO_Pin));
 216   3         }
 217   2        }else if(GPIOx == GPIO_PORT_2)
 218   1        {
 219   2         if (GPIO_BitVal != _RESET)
 220   2         {
 221   3            P2  |= (1 << GPIO_Pin);
 222   3         }else
 223   2         {
 224   3            P2  &= (uint8_t)(~(1 << GPIO_Pin));
 225   3         }
 226   2        }else if(GPIOx == GPIO_PORT_3)
 227   1        {
 228   2         if (GPIO_BitVal != _RESET)
 229   2         {
 230   3            P3  |= (1 << GPIO_Pin);
 231   3         }else
 232   2         {
 233   3            P3  &= (uint8_t)(~(1 << GPIO_Pin));
 234   3         }
 235   2        }else
 236   1        {
 237   2      
 238   2        }
 239   1      }
 240          #endif
 241          
 242          /**
 243            * @brief  Writes high level to the specified GPIO pins.
 244            * @note   The port must be configured in output mode.
 245            * @param  GPIOx : Select the GPIO peripheral number (x = A to I).
 246            * @param  GPIO_Pin : Specifies the pins to be turned high.
 247            * @retval None
 248            */
 249          void GPIO_SetBits(GPIO_Port_Typedef GPIOx, uint8_t GPIO_Pin)
 250          {
 251   1        if(GPIOx == GPIO_PORT_0)
 252   1        {
 253   2        P0 |= GPIO_Pin;
 254   2        }else if(GPIOx == GPIO_PORT_1)
 255   1        {
 256   2        P1 |= GPIO_Pin;
 257   2        }else if(GPIOx == GPIO_PORT_2)
 258   1        {
 259   2        P2 |= GPIO_Pin;
 260   2        }else if(GPIOx == GPIO_PORT_3)
 261   1        {
 262   2        P3 |= GPIO_Pin;
 263   2        }else
 264   1        {
 265   2      
 266   2        }
 267   1      }
 268          
 269          /**
 270            * @brief  Writes low level to the specified GPIO pins.
 271            * @param  GPIOx : Select the GPIO peripheral number (x = A to I).
 272            * @param  GPIO_Pin : Specifies the pins to be turned low
 273            * @retval None
 274            * @par    Required preconditions:
 275            *   The port must be configured in output mode.
 276            */
C51 COMPILER V9.56.0.0   CMS8S003X_GPIO                                                    05/29/2018 18:09:10 PAGE 6   

 277          void GPIO_ResetBits(GPIO_Port_Typedef GPIOx, uint8_t GPIO_Pin)
 278          {
 279   1        if(GPIOx == GPIO_PORT_0)
 280   1        {
 281   2        P0  &= (uint8_t)(~GPIO_Pin);
 282   2        }else if(GPIOx == GPIO_PORT_1)
 283   1        {
 284   2        P1 &= (uint8_t)(~GPIO_Pin);
 285   2        }else if(GPIOx == GPIO_PORT_2)
 286   1        {
 287   2        P2 &= (uint8_t)(~GPIO_Pin);
 288   2        }else if(GPIOx == GPIO_PORT_3)
 289   1        {
 290   2        P3 &= (uint8_t)(~GPIO_Pin);
 291   2        }else
 292   1        {
 293   2      
 294   2        }
 295   1      }
 296          
 297          /**
 298            * @brief  Toggles the specified GPIO pins.
 299            * @note   The port must be configured in output mode.
 300            * @param  GPIOx : Select the GPIO peripheral number (x = A to I).
 301            * @param  GPIO_Pin : Specifies the pins to be toggled.
 302            * @retval None
 303            */
 304          void GPIO_ToggleBits(GPIO_Port_Typedef GPIOx, uint8_t GPIO_Pin)
 305          {
 306   1        if(GPIOx == GPIO_PORT_0)
 307   1        {
 308   2        P0  ^= GPIO_Pin;
 309   2        }else if(GPIOx == GPIO_PORT_1)
 310   1        {
 311   2        P1 ^= GPIO_Pin;
 312   2        }else if(GPIOx == GPIO_PORT_2)
 313   1        {
 314   2        P2 ^= GPIO_Pin;
 315   2        }else if(GPIOx == GPIO_PORT_3)
 316   1        {
 317   2        P3 ^= GPIO_Pin;
 318   2        }else
 319   1        {
 320   2      
 321   2        }
 322   1      }
 323          
 324          /**
 325            * @brief  Reads the specified GPIO input data port.
 326            * @note   The port must be configured in input mode.
 327            * @param  GPIOx : Select the GPIO peripheral number (x = A to I).
 328            * @retval The GPIOx input data port value.
 329            */
 330          uint8_t GPIO_ReadInputData(GPIO_Port_Typedef GPIOx)
 331          {
 332   1        uint8_t dataRead = 0;
 333   1        if(GPIOx == GPIO_PORT_0)
 334   1        {
 335   2        dataRead = (uint8_t)P0;
 336   2        }else if(GPIOx == GPIO_PORT_1)
 337   1        {
 338   2        dataRead = (uint8_t)P1;
C51 COMPILER V9.56.0.0   CMS8S003X_GPIO                                                    05/29/2018 18:09:10 PAGE 7   

 339   2        }else if(GPIOx == GPIO_PORT_2)
 340   1        {
 341   2        dataRead = (uint8_t)P2;
 342   2        }else if(GPIOx == GPIO_PORT_3)
 343   1        {
 344   2        dataRead = (uint8_t)P3;
 345   2        }else
 346   1        {
 347   2      
 348   2        }
 349   1        return dataRead;
 350   1      }
 351          
 352          /**
 353            * @brief  Reads the specified GPIO output data port.
 354            * @note   The port must be configured in input mode.
 355            * @param  GPIOx : Select the GPIO peripheral number (x = A to I).
 356            * @retval The GPIOx  output data port value.
 357            */
 358          uint8_t GPIO_ReadOutputData(GPIO_Port_Typedef GPIOx)
 359          {
 360   1        uint8_t dataRead = 0;
 361   1        if(GPIOx == GPIO_PORT_0)
 362   1        {
 363   2        dataRead = (uint8_t)P0;
 364   2        }else if(GPIOx == GPIO_PORT_1)
 365   1        {
 366   2        dataRead = (uint8_t)P1;
 367   2        }else if(GPIOx == GPIO_PORT_2)
 368   1        {
 369   2        dataRead = (uint8_t)P2;
 370   2        }else if(GPIOx == GPIO_PORT_3)
 371   1        {
 372   2        dataRead = (uint8_t)P3;
 373   2        }else
 374   1        {
 375   2      
 376   2        }
 377   1        return dataRead;
 378   1      }
 379          
 380          /**
 381            * @brief  Reads the specified GPIO input data pin.
 382            * @param  GPIOx : Select the GPIO peripheral number (x = A to I).
 383            * @param  GPIO_Pin : Specifies the pin number.
 384            * @retval BitStatus : GPIO input pin status.
 385            */
 386          BitStatus GPIO_ReadInputDataBit(GPIO_Port_Typedef GPIOx, GPIO_Pin_TypeDef GPIO_Pin)
 387          {
 388   1        uint8_t dataRead = 0;
 389   1        if(GPIOx == GPIO_PORT_0)
 390   1        {
 391   2        dataRead = ((BitStatus)(P0 & (uint8_t)GPIO_Pin));
 392   2        }else if(GPIOx == GPIO_PORT_1)
 393   1        {
 394   2        dataRead = ((BitStatus)(P1 & (uint8_t)GPIO_Pin));
 395   2        }else if(GPIOx == GPIO_PORT_2)
 396   1        {
 397   2        dataRead = ((BitStatus)(P2 & (uint8_t)GPIO_Pin));
 398   2        }else if(GPIOx == GPIO_PORT_3)
 399   1        {
 400   2        dataRead = ((BitStatus)(P3 & (uint8_t)GPIO_Pin));
C51 COMPILER V9.56.0.0   CMS8S003X_GPIO                                                    05/29/2018 18:09:10 PAGE 8   

 401   2        }else
 402   1        {
 403   2      
 404   2        }
 405   1        return dataRead;
 406   1      }
 407          
 408          /**
 409            * @brief  Reads the specified GPIO Output data pin.
 410            * @param  GPIOx : Select the GPIO peripheral number (x = A to I).
 411            * @param  GPIO_Pin : Specifies the pin number
 412            * @retval BitStatus : GPIO output pin status.
 413            */
 414          BitStatus GPIO_ReadOutputDataBit(GPIO_Port_Typedef GPIOx, GPIO_Pin_TypeDef GPIO_Pin)
 415          {
 416   1        uint8_t dataRead = 0;
 417   1        if(GPIOx == GPIO_PORT_0)
 418   1        {
 419   2        dataRead = ((BitStatus)(P0 & (uint8_t)GPIO_Pin));
 420   2        }else if(GPIOx == GPIO_PORT_1)
 421   1        {
 422   2        dataRead = ((BitStatus)(P1 & (uint8_t)GPIO_Pin));
 423   2        }else if(GPIOx == GPIO_PORT_2)
 424   1        {
 425   2        dataRead = ((BitStatus)(P2 & (uint8_t)GPIO_Pin));
 426   2        }else if(GPIOx == GPIO_PORT_3)
 427   1        {
 428   2        dataRead = ((BitStatus)(P3 & (uint8_t)GPIO_Pin));
 429   2        }else
 430   1        {
 431   2      
 432   2        }
 433   1        return dataRead;
 434   1      }
 435          
 436          
 437          
 438          /**
 439            * @}
 440            */
 441          
 442          /**
 443            * @}
 444            */
 445          
 446          /******************* (C) COPYRIGHT 2018 CMSemicon *****END OF FILE****/
 447          


MODULE INFORMATION:   STATIC OVERLAYABLE
   CODE SIZE        =   2215    ----
   CONSTANT SIZE    =   ----    ----
   XDATA SIZE       =   ----    ----
   PDATA SIZE       =   ----    ----
   DATA SIZE        =      1       1
   IDATA SIZE       =   ----    ----
   BIT SIZE         =   ----    ----
   EDATA SIZE       =   ----    ----
   HDATA SIZE       =   ----    ----
   XDATA CONST SIZE =   ----    ----
   FAR CONST SIZE   =   ----    ----
END OF MODULE INFORMATION.

C51 COMPILER V9.56.0.0   CMS8S003X_GPIO                                                    05/29/2018 18:09:10 PAGE 9   


C51 COMPILATION COMPLETE.  1 WARNING(S),  0 ERROR(S)
